<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fitting a Next Generation Reservoir Computer · ReservoirComputing.jl</title><meta name="title" content="Fitting a Next Generation Reservoir Computer · ReservoirComputing.jl"/><meta property="og:title" content="Fitting a Next Generation Reservoir Computer · ReservoirComputing.jl"/><meta property="twitter:title" content="Fitting a Next Generation Reservoir Computer · ReservoirComputing.jl"/><meta name="description" content="Documentation for ReservoirComputing.jl."/><meta property="og:description" content="Documentation for ReservoirComputing.jl."/><meta property="twitter:description" content="Documentation for ReservoirComputing.jl."/><meta property="og:url" content="https://docs.sciml.ai/ReservoirComputing/stable/tutorials/ngrc/"/><meta property="twitter:url" content="https://docs.sciml.ai/ReservoirComputing/stable/tutorials/ngrc/"/><link rel="canonical" href="https://docs.sciml.ai/ReservoirComputing/stable/tutorials/ngrc/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ReservoirComputing.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ReservoirComputing.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">ReservoirComputing.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../scratch/">Building a model from scratch</a></li><li><a class="tocitem" href="../lorenz_basic/">Chaos forecasting with an ESN</a></li><li class="is-active"><a class="tocitem" href>Fitting a Next Generation Reservoir Computer</a><ul class="internal"><li><a class="tocitem" href="#1.-Setup-and-imports"><span>1. Setup and imports</span></a></li><li><a class="tocitem" href="#2.-Define-Lorenz-system-and-generate-data"><span>2. Define Lorenz system and generate data</span></a></li><li><a class="tocitem" href="#3.-Normalization"><span>3. Normalization</span></a></li><li><a class="tocitem" href="#4.-Build-the-NGRC-model"><span>4. Build the NGRC model</span></a></li><li><a class="tocitem" href="#5.-Training-the-NGRC-readout"><span>5. Training the NGRC readout</span></a></li><li><a class="tocitem" href="#6.-Generative-prediction"><span>6. Generative prediction</span></a></li><li><a class="tocitem" href="#7.-Visualization"><span>7. Visualization</span></a></li></ul></li><li><a class="tocitem" href="../deep_esn/">Deep Echo State Networks</a></li><li><a class="tocitem" href="../reca/">Reservoir Computing with Cellular Automata</a></li></ul></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../../api/layers/">Layers</a></li><li><a class="tocitem" href="../../api/models/">Models</a></li><li><a class="tocitem" href="../../api/utils/">Utilities</a></li><li><a class="tocitem" href="../../api/train/">Train</a></li><li><a class="tocitem" href="../../api/predict/">Predict</a></li><li><a class="tocitem" href="../../api/states/">States</a></li><li><a class="tocitem" href="../../api/inits/">Initializers</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Fitting a Next Generation Reservoir Computer</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fitting a Next Generation Reservoir Computer</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ReservoirComputing.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ReservoirComputing.jl/blob/master/docs/src/tutorials/ngrc.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Next-Generation-Reservoir-Computing"><a class="docs-heading-anchor" href="#Next-Generation-Reservoir-Computing">Next Generation Reservoir Computing</a><a id="Next-Generation-Reservoir-Computing-1"></a><a class="docs-heading-anchor-permalink" href="#Next-Generation-Reservoir-Computing" title="Permalink"></a></h1><p>This tutorial shows how to use next generation reservoir computing <a href="../../api/models/#ReservoirComputing.NGRC">NGRC</a> in ReservoirComputing.jl to model the chaotic Lorenz system.</p><p>NGRC works differently compared to traditional reservoir computing. In NGRC the reservoir is replaced with:</p><ul><li>A delay embedding of the input</li><li>A nonlinear feature map</li></ul><p>The model is finally trained through ridge regression, like a normal RC.</p><p>In this tutorial we will :</p><ul><li>simulate the Lorenz system,</li><li>build an NGRC model with delayed inputs and polynomial features, following the <a href="https://doi.org/10.1038/s41467-021-25801-2">original paper</a>,</li><li>train it on one-step increments,</li><li>roll it out generatively and compare with the true trajectory.</li></ul><h2 id="1.-Setup-and-imports"><a class="docs-heading-anchor" href="#1.-Setup-and-imports">1. Setup and imports</a><a id="1.-Setup-and-imports-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Setup-and-imports" title="Permalink"></a></h2><p>First we need to load the necessary packages. We are going to use the following:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq
using Random
using ReservoirComputing
using Plots
using Statistics</code></pre><h2 id="2.-Define-Lorenz-system-and-generate-data"><a class="docs-heading-anchor" href="#2.-Define-Lorenz-system-and-generate-data">2. Define Lorenz system and generate data</a><a id="2.-Define-Lorenz-system-and-generate-data-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Define-Lorenz-system-and-generate-data" title="Permalink"></a></h2><p>We define the Lorenz system and integrate it to generate a long trajectory:</p><pre><code class="language-julia hljs">function lorenz!(du, u, p, t)
    σ, ρ, β = p
    du[1] = σ * (u[2] - u[1])
    du[2] = u[1] * (ρ - u[3]) - u[2]
    du[3] = u[1] * u[2] - β * u[3]
end

prob = ODEProblem(
    lorenz!,
    Float32[1.0, 0.0, 0.0],
    (0.0, 200.0),
    (10.0f0, 28.0f0, 8/3f0),
)

data = Array(solve(prob, ABM54(); dt = 0.025))  # size: (3, T)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×8001 Matrix{Float32}:
 1.0  0.853731    0.870095   1.01244   …   0.773916   0.851587   0.970214
 0.0  0.628894    1.20067    1.81407       1.00348    1.24317    1.5298
 0.0  0.00700958  0.0254547  0.057893     15.2662    14.3036    13.4116</code></pre><p>We then split the time series into training and testing segments:</p><pre><code class="language-julia hljs">shift = 300
train_len = 500
predict_len = 900

input_data = data[:, shift:(shift + train_len - 1)]
target_data = data[:, (shift + 1):(shift + train_len)]
test_data = data[:, (shift + train_len):(shift + train_len + predict_len - 1)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×900 Matrix{Float32}:
 -2.80319  -3.30617  -3.805    -4.33585  …  -4.03219  -3.6886   -3.50096
 -4.87985  -5.28285  -5.84278  -6.56417     -2.32134  -2.63856  -3.03897
 21.6032   20.5856   19.7363   19.0738      24.739    23.3732   22.1111</code></pre><h2 id="3.-Normalization"><a class="docs-heading-anchor" href="#3.-Normalization">3. Normalization</a><a id="3.-Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Normalization" title="Permalink"></a></h2><p>It is good practice to normalize the data, especially for polynomial features:</p><pre><code class="language-julia hljs">in_mean = mean(input_data; dims = 2)
in_std = std(input_data;  dims = 2)

train_norm_x = (input_data  .- in_mean) ./ in_std
train_norm_y = (target_data .- in_mean) ./ in_std
test_norm_x  = (test_data   .- in_mean) ./ in_std

# We train an increment (residual) model: Δy = y_{t+1} − y_t
train_delta_y = train_norm_y .- train_norm_x</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×500 Matrix{Float32}:
  0.00105339  -0.0136562  -0.0277029  …  -0.129007    -0.102032   -0.0856874
 -0.0517914   -0.0628898  -0.0724724      0.00232842  -0.0147804  -0.0343755
 -0.0859328   -0.0697899  -0.0504105     -0.220857    -0.194563   -0.170794</code></pre><h2 id="4.-Build-the-NGRC-model"><a class="docs-heading-anchor" href="#4.-Build-the-NGRC-model">4. Build the NGRC model</a><a id="4.-Build-the-NGRC-model-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Build-the-NGRC-model" title="Permalink"></a></h2><p>Now that we have the data we can start building the model. Following the approach of the paper we first define two feature functions:</p><ul><li>a constant feature</li><li>a second order polynomial monomial </li></ul><pre><code class="language-julia hljs">const_feature = x -&gt; Float32[1.0]
poly_feature  = x -&gt; polynomial_monomials(x; degrees = 1:2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#5 (generic function with 1 method)</code></pre><p>Finally, we can construct the NGRC model.</p><p>We set the following:</p><pre><code class="language-julia hljs">in_dims = 3
out_dims = 3
num_delays = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>With <code>in_dims=3</code> and <code>num_delays=1</code> the delayed input length is 6. Adding the polinomial of degrees 1 and 2 will put give us 21 more. Finally, the constant term adds 1 more feature. In total we have 28 features. </p><p>We can pass the number of features to <code>ro_dims</code> to initialize the <a href="../../api/layers/#ReservoirComputing.LinearReadout"><code>LinearReadout</code></a> with the correct dimensions. However, unless one is planning to fry run the model without training, the <a href="../../api/train/#ReservoirComputing.train"><code>train</code></a> function will take care to adjust the dimensions.</p><p>Now we build the NGRC:</p><pre><code class="language-julia hljs">rng = MersenneTwister(0)

ngrc = NGRC(in_dims, out_dims; num_delays = num_delays, stride = 1, features = (const_feature, poly_feature),
    include_input = false,  # we already encode everything in the features
    ro_dims = 28,
    readout_activation = identity)

ps, st = setup(rng, ngrc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((reservoir = NamedTuple(), states_modifiers = (NamedTuple(),), readout = (weight = Float32[0.40952146 0.18945241 … 0.49384677 0.2657143; 0.9514209 0.5826452 … 0.36021674 0.11498523; 0.9727092 0.9875822 … 0.7525219 0.34456646],)), (reservoir = (history = nothing, clock = 0, rng = Random.MersenneTwister(0, (0, 1002, 0, 42))), states_modifiers = (NamedTuple(),), readout = NamedTuple()))</code></pre><p>At this point, <code>ngrc</code> is a fully specified model with:</p><ul><li>a <a href="../../api/layers/#ReservoirComputing.DelayLayer"><code>DelayLayer</code></a> that builds a 6-dimensional delayed vector from the 3D input,</li><li>a <a href="../../api/layers/#ReservoirComputing.NonlinearFeaturesLayer"><code>NonlinearFeaturesLayer</code></a> that maps that vector to 28 polynomial features,</li><li>a <a href="../../api/layers/#ReservoirComputing.LinearReadout"><code>LinearReadout</code></a> (28 =&gt; 3).</li></ul><h2 id="5.-Training-the-NGRC-readout"><a class="docs-heading-anchor" href="#5.-Training-the-NGRC-readout">5. Training the NGRC readout</a><a id="5.-Training-the-NGRC-readout-1"></a><a class="docs-heading-anchor-permalink" href="#5.-Training-the-NGRC-readout" title="Permalink"></a></h2><p>We now train the linear readout using ridge regression on the increment <code>train_delta_y</code>:</p><pre><code class="language-julia hljs">ps, st = train!(ngrc, train_norm_x, train_delta_y, ps, st;
    train_method = StandardRidge(2.5e-6))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((reservoir = NamedTuple(), states_modifiers = (NamedTuple(),), readout = (weight = [0.01256861507860827 -0.3130767720322529 … 0.01673971106242916 0.00017023951877271227; 0.11887351736169234 -1.0723469973814994 … 0.1915114531838363 -0.035128558380638705; -0.09375234415761531 3.3096494712679454 … 0.03954448961534765 0.10612467302178624],)), (reservoir = (history = Float32[0.4247307; 0.044810098; -0.3092905;;], clock = 500, rng = Random.MersenneTwister(0, (0, 1002, 0, 42))), states_modifiers = (NamedTuple(),), readout = NamedTuple()))</code></pre><p>where <a href="../../api/train/#ReservoirComputing.StandardRidge"><code>StandardRidge</code></a> is the ridge regression provided natively by ReservoirComputing.jl.</p><h2 id="6.-Generative-prediction"><a class="docs-heading-anchor" href="#6.-Generative-prediction">6. Generative prediction</a><a id="6.-Generative-prediction-1"></a><a class="docs-heading-anchor-permalink" href="#6.-Generative-prediction" title="Permalink"></a></h2><p>We now perform generative prediction on the increments to obtain the predicted time series:</p><pre><code class="language-julia hljs">single_step = copy(test_norm_x[:, 1]) # normalized initial condition
traj_norm = similar(test_norm_x, 3, predict_len)

for step in 1:predict_len
    global st
    delta_step, st = ngrc(single_step, ps, st)
    single_step .= single_step .+ delta_step # increment update in normalized space
    traj_norm[:, step] .= single_step
end</code></pre><p>Finally, we unscale back to the original coordinates:</p><pre><code class="language-julia hljs">traj = traj_norm .* in_std .+ in_mean # size: (3, predict_len)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×900 Matrix{Float32}:
 -3.30616  -3.80449  -4.33391  -4.92376  …   7.20849   4.8467    2.90777
 -5.28191  -5.83858  -6.55609  -7.43775     -2.96956  -3.78466  -3.99589
 20.5876   19.7407   19.0804   18.637       35.4879   32.7212   30.2604</code></pre><h2 id="7.-Visualization"><a class="docs-heading-anchor" href="#7.-Visualization">7. Visualization</a><a id="7.-Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#7.-Visualization" title="Permalink"></a></h2><p>We can now compare the predicted trajectory with the true Lorenz data on the test segment:</p><pre><code class="language-julia hljs">plot(transpose(test_data)[:, 1], transpose(test_data)[:, 2], transpose(test_data)[:, 3]; label=&quot;actual&quot;);
plot!(transpose(traj)[:, 1], transpose(traj)[:, 2], transpose(traj)[:, 3]; label=&quot;predicted&quot;)</code></pre><img src="b953282f.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lorenz_basic/">« Chaos forecasting with an ESN</a><a class="docs-footer-nextpage" href="../deep_esn/">Deep Echo State Networks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 10 December 2025 17:38">Wednesday 10 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
