<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Chaos forecasting with an ESN · ReservoirComputing.jl</title><meta name="title" content="Chaos forecasting with an ESN · ReservoirComputing.jl"/><meta property="og:title" content="Chaos forecasting with an ESN · ReservoirComputing.jl"/><meta property="twitter:title" content="Chaos forecasting with an ESN · ReservoirComputing.jl"/><meta name="description" content="Documentation for ReservoirComputing.jl."/><meta property="og:description" content="Documentation for ReservoirComputing.jl."/><meta property="twitter:description" content="Documentation for ReservoirComputing.jl."/><meta property="og:url" content="https://docs.sciml.ai/ReservoirComputing/stable/tutorials/lorenz_basic/"/><meta property="twitter:url" content="https://docs.sciml.ai/ReservoirComputing/stable/tutorials/lorenz_basic/"/><link rel="canonical" href="https://docs.sciml.ai/ReservoirComputing/stable/tutorials/lorenz_basic/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ReservoirComputing.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ReservoirComputing.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">ReservoirComputing.jl</a></li><li><a class="tocitem" href="../getting_started/">Getting Started with ReservoirComputing.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../scratch/">Building a model from scratch</a></li><li class="is-active"><a class="tocitem" href>Chaos forecasting with an ESN</a><ul class="internal"><li><a class="tocitem" href="#Generating-the-data"><span>Generating the data</span></a></li><li><a class="tocitem" href="#Building-the-Echo-State-Network"><span>Building the Echo State Network</span></a></li><li><a class="tocitem" href="#Training-and-Prediction"><span>Training and Prediction</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../ngrc/">Fitting a Next Generation Reservoir Computer</a></li><li><a class="tocitem" href="../deep_esn/">Deep Echo State Networks</a></li><li><a class="tocitem" href="../reca/">Reservoir Computing with Cellular Automata</a></li><li><a class="tocitem" href="../saveload/">Saving and loading models</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/model_es2n/">Building a model to add to ReservoirComputing.jl</a></li></ul></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../../api/layers/">Layers</a></li><li><a class="tocitem" href="../../api/models/">Models</a></li><li><a class="tocitem" href="../../api/utils/">Utilities</a></li><li><a class="tocitem" href="../../api/train/">Train</a></li><li><a class="tocitem" href="../../api/predict/">Predict</a></li><li><a class="tocitem" href="../../api/states/">States</a></li><li><a class="tocitem" href="../../api/inits/">Initializers</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Chaos forecasting with an ESN</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Chaos forecasting with an ESN</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ReservoirComputing.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ReservoirComputing.jl/blob/master/docs/src/tutorials/lorenz_basic.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lorenz-System-Forecasting"><a class="docs-heading-anchor" href="#Lorenz-System-Forecasting">Lorenz System Forecasting</a><a id="Lorenz-System-Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#Lorenz-System-Forecasting" title="Permalink"></a></h1><p>This example expands on the readme Lorenz system forecasting to showcase how to use models and methods provided in the library for Echo State Networks.</p><h2 id="Generating-the-data"><a class="docs-heading-anchor" href="#Generating-the-data">Generating the data</a><a id="Generating-the-data-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-the-data" title="Permalink"></a></h2><p>Starting off the workflow, the first step is to obtain the data. We use <code>OrdinaryDiffEq</code> to derive the Lorenz system data. The data is passed to the model as a matrix, where the columns represent the time steps.</p><pre><code class="language-julia hljs">using OrdinaryDiffEq

#define lorenz system
function lorenz!(du, u, p, t)
    du[1] = 10.0 * (u[2] - u[1])
    du[2] = u[1] * (28.0 - u[3]) - u[2]
    du[3] = u[1] * u[2] - (8 / 3) * u[3]
end

#solve and take data
prob = ODEProblem(lorenz!, [1.0, 0.0, 0.0], (0.0, 200.0))
data = solve(prob, ABM54(); dt=0.02)
data = reduce(hcat, data.u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×10001 Matrix{Float64}:
 1.0  0.868014    0.846922   0.912746   …  -5.41248   -4.48696   -3.72246
 0.0  0.511611    0.972162   1.43659       -0.380216  -0.265298  -0.291495
 0.0  0.00464843  0.0167238  0.0363891     29.841     28.3209    26.8714</code></pre><p>Now we split the data in training and testing. To do an autoregressive forecast we want the model to be trained on the next step, so we are going to shift the target data by one. Additionally, we discard the transient period.</p><pre><code class="language-julia hljs">#determine shift length, training length and prediction length
shift = 300
train_len = 5000
predict_len = 1250

#split the data accordingly
input_data = data[:, shift:(shift + train_len - 1)]
target_data = data[:, (shift + 1):(shift + train_len)]
test_data = data[:, (shift + train_len + 1):(shift + train_len + predict_len)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×1250 Matrix{Float64}:
  4.2235    3.83533   3.55846   3.38262  …   9.44212  10.0034  10.5085
  1.98782   2.18137   2.43519   2.7396      12.3382   12.6956  12.8396
 25.6556   24.4858   23.3794   22.3394      24.3255   25.4374  26.6729</code></pre><p>It is <em>important</em> to notice that the data needs to be formatted in a matrix with the features as rows and time steps as columns as in this example. This is needed even if the time series consists of single values.</p><h2 id="Building-the-Echo-State-Network"><a class="docs-heading-anchor" href="#Building-the-Echo-State-Network">Building the Echo State Network</a><a id="Building-the-Echo-State-Network-1"></a><a class="docs-heading-anchor-permalink" href="#Building-the-Echo-State-Network" title="Permalink"></a></h2><p>Once the data is ready, it is possible to define the parameters for the ESN and the <code>ESN</code> struct itself. In this example, the values from (<a href="../../references/#Pathak2017">Pathak <em>et al.</em>, 2017</a>) are loosely followed as general guidelines.</p><pre><code class="language-julia hljs">using ReservoirComputing

#define ESN parameters
res_size = 300
in_size = 3
res_radius = 1.2
res_sparsity = 6 / 300
input_scaling = 0.1

#build ESN struct
esn = ESN(in_size, res_size, in_size; #autoregressive so in_size = out_size
    init_reservoir = rand_sparse(; radius = res_radius, sparsity = res_sparsity),
    init_input = weighted_init(; scaling = input_scaling),
    state_modifiers = NLAT2
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ESN(
    reservoir = StatefulLayer(ESNCell(3 =&gt; 300, use_bias=false)),
    state_modifiers = (WrappedFunction(NLAT2)),
    readout = LinearReadout(300 =&gt; 3, use_bias=false, include_collect=true)
)</code></pre><p>In this case, a size of 300 has been chosen, so the reservoir matrix will be 300 x 300. However, this is not always the case, since some input layer constructions can modify the dimensions of the reservoir. Please make sure to read the API documentation of the initializer you intend to use if you think that is cause of errors.</p><p>The <code>res_radius</code> determines the scaling of the spectral radius of the reservoir matrix; a proper scaling is necessary to assure the Echo State Property. The default value in the <a href="../../api/inits/rand_sparse/#rand_sparse"><code>rand_sparse</code></a> method is 1.0 in accordance with the most commonly followed guidelines found in the literature (see (<a href="../../references/#Lukoeviius2012">Lukoševičius, 2012</a>) and references therein).</p><p>The value of <code>input_scaling</code> determines the upper and lower bounds of the uniform distribution of the weights in the <a href="../../api/inits/weighted_init/#weighted_init"><code>weighted_init</code></a>. The value of 0.1 represents the default. The default input layer is the <a href="../../api/inits/scaled_rand/#scaled_rand"><code>scaled_rand</code></a>, a dense matrix. The details of the weighted version can be found in (<a href="../../references/#Lu2017">Lu <em>et al.</em>, 2017</a>). For this example, this version returns the best results.</p><h2 id="Training-and-Prediction"><a class="docs-heading-anchor" href="#Training-and-Prediction">Training and Prediction</a><a id="Training-and-Prediction-1"></a><a class="docs-heading-anchor-permalink" href="#Training-and-Prediction" title="Permalink"></a></h2><p>Training for ESNs usually means solving a linear regression. The library supports solvers from <a href="https://github.com/JuliaAI/MLJLinearModels.jl">MLJLinearModels.jl</a>, in addition to a custom implementation of ridge regression. In this example we will use the latter.</p><p>Since <code>ReservoirComputing.jl</code> builds on <a href="https://lux.csail.mit.edu/stable/api/Building_Blocks/LuxCore"><code>LuxCore.jl</code></a> we first need to setup the state and the parameters</p><pre><code class="language-julia hljs">using Random
Random.seed!(42)
rng = MersenneTwister(17)

ps, st = setup(rng, esn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((reservoir = (input_matrix = Float32[0.07099056 0.0 0.0; 0.044342138 0.0 0.0; … ; 0.0 0.0 0.04174912; 0.0 0.0 -0.017985344], reservoir_matrix = Float32[0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]), states_modifiers = (NamedTuple(),), readout = (weight = Float32[0.14745247 0.31642652 … 0.79039073 0.70270693; 0.50063944 0.76482 … 0.04451108 0.991169; 0.54582596 0.87618923 … 0.6872307 0.841046],)), (reservoir = (cell = (rng = Random.MersenneTwister(17, (0, 222892, 221442, 206)),), carry = nothing), states_modifiers = (NamedTuple(),), readout = NamedTuple()))</code></pre><p>Now we can proceed with training the ESN model. Usually an initial transient is discarded, to account for the dynamics of the ESN to settle. This can be done by passing the <code>washout</code> keyword argument to <code>train</code>.</p><pre><code class="language-julia hljs">#define training method
training_method = StandardRidge(0.0)

ps, st = train!(esn, input_data, target_data, ps, st, training_method)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((reservoir = (input_matrix = Float32[0.07099056 0.0 0.0; 0.044342138 0.0 0.0; … ; 0.0 0.0 0.04174912; 0.0 0.0 -0.017985344], reservoir_matrix = Float32[0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]), states_modifiers = (NamedTuple(),), readout = (weight = [1.2487366212787159 0.3608088980889213 … -4.157544427654357 -1.0415952644203579; -5.331389418381886 1.150675640316377 … -3.5291204282706916 2.4630478845661146; -2.992302934735261 -5.052152248931234 … -28.267005934702695 -7.0141298550094975],)), (reservoir = (cell = (rng = Random.MersenneTwister(17, (0, 222892, 221442, 511)),), carry = ([0.8277185641321425; 0.41136255864703053; … ; 0.95331859880098; -0.7840850804516452;;],)), states_modifiers = (NamedTuple(),), readout = NamedTuple()))</code></pre><p><code>ps</code> now contains the trained parameters for the ESN.</p><div class="admonition is-info" id="Returning-training-states-b551732731b10e73"><header class="admonition-header">Returning training states<a class="admonition-anchor" href="#Returning-training-states-b551732731b10e73" title="Permalink"></a></header><div class="admonition-body"><p>The ESN states are internally used the training, however they are not returned by default. To inspect the states, it is necessary to set the boolean keyword argument <code>return_states</code> as <code>true</code> in the <a href="../../api/train/#ReservoirComputing.train!"><code>train!</code></a> call.</p></div></div><p>ReservoirComputing.jl provides additional utilities functions for autoregressive forecasting:</p><pre><code class="language-julia hljs">output, st = predict(esn, predict_len, ps, st; initialdata=test_data[:, 1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([3.9612472483120205 3.674253796184256 … 5.148217913096575 4.98423817470443; 2.5445960824137757 3.0314970938102164 … 4.101730831742827 4.3886715639620135; 24.290769758470894 23.162757704157244 … 24.765933294389278 23.89736653858111], (reservoir = (cell = (rng = Random.MersenneTwister(17, (0, 222892, 221442, 511)),), carry = ([0.7948452772731637; 0.34587147188761536; … ; 0.935299377992348; -0.7474156250474757;;],)), states_modifiers = (NamedTuple(),), readout = NamedTuple()))</code></pre><p>To inspect the results, they can easily be plotted using an external library. In this case, we will use <code>Plots.jl</code>:</p><pre><code class="language-julia hljs">using Plots, Plots.PlotMeasures

ts = 0.0:0.02:200.0
lorenz_maxlyap = 0.9056
predict_ts = ts[(shift + train_len + 1):(shift + train_len + predict_len)]
lyap_time = (predict_ts .- predict_ts[1]) * (1 / lorenz_maxlyap)

p1 = plot(lyap_time, [test_data[1, :] output[1, :]]; label=[&quot;actual&quot; &quot;predicted&quot;],
    ylabel=&quot;x(t)&quot;, linewidth=2.5, xticks=false, yticks=-15:15:15);
p2 = plot(lyap_time, [test_data[2, :] output[2, :]]; label=[&quot;actual&quot; &quot;predicted&quot;],
    ylabel=&quot;y(t)&quot;, linewidth=2.5, xticks=false, yticks=-20:20:20);
p3 = plot(lyap_time, [test_data[3, :] output[3, :]]; label=[&quot;actual&quot; &quot;predicted&quot;],
    ylabel=&quot;z(t)&quot;, linewidth=2.5, xlabel=&quot;max(λ)*t&quot;, yticks=10:15:40);

plot(p1, p2, p3; plot_title=&quot;Lorenz System Coordinates&quot;,
    layout=(3, 1), xtickfontsize=12, ytickfontsize=12, xguidefontsize=15,
    yguidefontsize=15,
    legendfontsize=12, titlefontsize=20)</code></pre><img src="922eac86.svg" alt="Example block output"/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation noncanonical"><ul><li><div>Lu, Z.; Pathak, J.; Hunt, B.; Girvan, M.; Brockett, R. and Ott, E. (2017). <a href="http://dx.doi.org/10.1063/1.4979665"><em>Reservoir observers: Model-free inference of unmeasured variables in chaotic systems</em></a>. <a href="https://doi.org/10.1063/1.4979665">Chaos: An Interdisciplinary Journal of Nonlinear Science <strong>27</strong></a>.</div></li><li><div>Lukoševičius, M. (2012). <a href="http://dx.doi.org/10.1007/978-3-642-35289-8_36"><em>A Practical Guide to Applying Echo State Networks</em></a>. In: <a href="https://doi.org/10.1007/978-3-642-35289-8_36"><em>Neural Networks: Tricks of the Trade</em></a> (Springer Berlin Heidelberg); pp. 659–686.</div></li><li><div>Pathak, J.; Lu, Z.; Hunt, B. R.; Girvan, M. and Ott, E. (2017). <a href="http://dx.doi.org/10.1063/1.5010300"><em>Using machine learning to replicate chaotic attractors and calculate Lyapunov exponents from data</em></a>. <a href="https://doi.org/10.1063/1.5010300">Chaos: An Interdisciplinary Journal of Nonlinear Science <strong>27</strong></a>.</div></li></ul></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../scratch/">« Building a model from scratch</a><a class="docs-footer-nextpage" href="../ngrc/">Fitting a Next Generation Reservoir Computer »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 24 January 2026 18:13">Saturday 24 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
